PROGRAM HOWFULL
IMPLICIT NONE

!----------------------------------------------------------------------
!
! PROGRAM       : HOWFULL
!
! PURPOSE       : To see how full certain kinds of MetDB data set are
!
! DATA TYPE(S)  : Any stored by programs which claim blocks only when
!                 needed (AIRSTO, ERSREP etc - any but TAFREP & clones)
!
! CALLS         : DATIM, ICHAR2                                    
!
! REVISION INFO :
!
! $Workfile: howfull.pre$
! $Revision: 2$ $Date: 30/10/2009 15:05:19$
! $Log:
!  2    Met_DB_Project 1.1         30/10/2009 15:05:19    Stan Kellett
!       tidied code and dynamic allocation for some large arrays
!  1    Met_DB_Project 1.0         16/10/2009 17:11:22    Stan Kellett    new
!       version of Howful main program.
!
!       This converted from f77 to f90 and has a .pre extension as it includes
!        preprocessor sttements
! $

! Initial revision
!-----------------------------------------------------------------------
! (C) CROWN COPYRIGHT 2009 - MET OFFICE. All Rights Reserved.
!
! Met Office, United Kingdom
!
! The use, duplication and disclosure of this code is strictly
! prohibited without the permission of The Meteorological Database
! Team at the above address.
!----------------------------------------------------------------------

! Parameter                                                       
!INTEGER    MAXIND      ! Upper limit of INDB array           
!PARAMETER (MAXIND=5000)                                      

!Declare Character
CHARACTER*1, dimension(:), allocatable :: MAP ! Complete MAP records (old format) 
CHARACTER*8 MAPHDR                            ! Map record header (old format)
CHARACTER*2 MAPTRL                            ! Map record trailer (old format)
CHARACTER*46 DSN                              ! Data set name
CHARACTER*80 LINE                             ! Line of output for unit 6           
CHARACTER*21 PREFIX                           ! Prefix for printout                 
CHARACTER*27998 MAPREC                        ! Map record (new format) 
INTEGER BLKSIZ                                ! Record length of storage data set
INTEGER I,J                                   ! Loop counters and other local use
INTEGER ICHAR2                                ! External function for C*2 --> I*4   
INTEGER, DIMENSION(:), ALLOCATABLE    :: INDB ! No. of data recs. for each index  
!INTEGER INDB(0:MAXIND)                        ! No. of data recs. for each index    
INTEGER IRC                                   ! Return code from I/O statement
INTEGER IS                                    ! Location of subtype name in DSN     
INTEGER IX                                    ! Index pointer in map record
INTEGER LDSN                                  ! Length of data set name             
INTEGER MAPLEN1                               ! Number of index pointers in map record
INTEGER MAX                                   ! Max. number of data records per index
INTEGER MEAN                                  ! Mean number of data records per index
INTEGER NB                                    ! Total number of records (old format)
INTEGER NDB                                   ! Number of data records
INTEGER NINDB                                 ! Highest INDB element to look at     
INTEGER NMAP                                  ! Number of current map record        
INTEGER NMAPBLK                               ! Total number of map records
INTEGER NOW(8)                                ! Date/time (as output from DATIM)
INTEGER NSEQBL                                ! Record number of BUFR sequence record
INTEGER NSQ                                   ! =1 if BUFR sequence record; else 0
INTEGER NUSE                                  ! % of data records in use
INTEGER NXB                                   ! Total number of index records
INTEGER NXM                                   ! Index period in minutes             
INTEGER IERR                                  ! error condition from open of storage dataset

CHARACTER HEAD*80                             ! Revision information                
CHARACTER*200 FILENAME                        ! File name and path of storage dataset

#if ! defined (MVS)
CHARACTER*200   STORAGE_DIR                                
#endif

HEAD = '$Workfile: howfull.pre$ ' //&
   &       '$Revision: 2$ $Date: 30/10/2009 15:05:19$'

!-----------------------------------------------------------------------
! get ENV VAR BASE_DIR from system
!-----------------------------------------------------------------------

#if ! defined (MVS)
CALL METDB_GETENV("STORAGE_DIR",STORAGE_DIR,I)               
#endif

! Open output file for statistics output.  
OPEN (10,FILE='DD:STATS',IOSTAT=IRC)                            

! Headings for tabulated output.                                   

CALL DATIM (NOW)                                             
I = MOD(NOW(8),100)  ! 2-digit year                          
WRITE (10,'(T12,A,2I2.2,A,I3.2,2(''/'',I2.2))')&              
    &          'MET.D.B. STORAGE DATA SET USAGE AT ',&            
    &           NOW(5), NOW(4), 'Z ON', NOW(6), NOW(7), I         
WRITE (10,'(T12,2A)') ('--------------------------',J=1,2)   
WRITE (10,'(/T31,A /T35,A)')&                                 
    &     '% Data records   Data records/index   Index period',&   
    &         'in use          Mean     Max.      (minutes)'     

! Loop round the data sets in the input list, opening each with the
! blocksize specified in the input.
! Read the map block. All the calculations will be based on the map.

! Pre-processor statement: DSN(1:1) = '/' only if platform is IBM. This
! is because on IBM , DSN names must start with a '/' to distinguish
! them from DDNAMEs                                                

#if defined (MVS)
DSN(1:1)='/'
#endif

IRC=0
DO WHILE (IRC.EQ.0)

! Pre-processor statement: If platform is IBM , read in DSN(2:46),
! otherwise read in DSN(1:45)                                      

#if defined (MVS)
   OPEN  (5,FILE='DD:INPUT',ACTION='READ',FORM='FORMATTED')
   READ (5,'(A45,I5)',IOSTAT=IRC) DSN(2:46),BLKSIZ
#else
   READ (5,'(A45,I5)',IOSTAT=IRC) DSN(1:45),BLKSIZ            
#endif

   LDSN=INDEX(DSN,' ')-1                                     
   IF (IRC.NE.0 .OR. LDSN.LE.4) GO TO 99                      
   MAPLEN1=BLKSIZ-LEN(MAPHDR)-LEN(MAPTRL)
   ALLOCATE (MAP(MAPLEN1))            

! Pre-processor statements: If platform is IBM, specify ACTION='READ'
! otherwise omit.                                                  

#if defined (MVS)
   FILENAME="//'"//DSN(2:LDSN)//"'"   ! required in this format to pick up on Z/OS
   
   OPEN (1,FILE=FILENAME,ACTION='READ',form='unformatted',& 
           ACCESS='DIRECT',RECL=BLKSIZ,IOSTAT=IERR)
	   
! If unit 1 fails to open then write out an error message and end program
   IF (IERR.NE.0) THEN
      WRITE(6,*)'fatal error opening unit 1 so exiting'
      WRITE(6,*)'unable to open ',FILENAME
      WRITE(6,*)'IOSTAT status = ',IERR
      STOP
   ENDIF
   
#else
   I=INDEX(STORAGE_DIR,' ')-1                                 
   FILENAME=STORAGE_DIR(1:I)//'/'//DSN(1:LDSN)                
   OPEN (1,FILE=FILENAME,FORM='UNFORMATTED',&                 
            ACCESS='DIRECT',RECL=BLKSIZ)                         
#endif
   READ (1,REC=1) MAPHDR,(MAP(I),I=1,MAPLEN1),MAPTRL

   NB = ICHAR2(MAPHDR(1:2))                                   
   IF (NB.GT.0) THEN               ! Old data set format      
      NXB = ICHAR2(MAPHDR(3:4))                               
      NXM = ICHAR2(MAPHDR(5:6))*60                            

! If the map has >12000 records look for it at the end of the data set.
! (The test on MAP(NXB+1) was added after storage data sets for    
! merged SUBSEA data were expanded beyond 12000 records but the    
! map was kept in record 1. MAP(NXB+1) is the byte for the first   
! data record and should never be 0 if the map is in record 1.)   

     IF (NB.GT.12000 .AND. MAP(NXB+1).EQ.CHAR(0)) THEN        
        NSEQBL=ICHAR(MAP(1))

        NMAPBLK=(NB+(BLKSIZ-1))/BLKSIZ
	
        DO J=1,NMAPBLK
           READ (1,REC=NB-NMAPBLK+J) (MAP(I),&
           I=(J-1)*BLKSIZ+1,MIN(J*BLKSIZ,NB))
        ENDDO
     ELSE
        NSEQBL = ICHAR(MAP(NB)) ! BUFR seq. block
     ENDIF

     NSQ=0
     IF (NSEQBL.GT.0) NSQ=1
     ALLOCATE (INDB(0:NXB+1))  
!                                            Clear out INDB array  
     DO I=0,NXB+1                                              
        INDB(I) = 0                                             
     END DO              

! The map byte for a data block shows which index block owns it.
! Loop round the data block bytes, counting data blocks owned by
! each index block - and those not in use (zero bytes) in INDB(0).
! (Some kinds of storage set the top bit to indicate overflow:     
!  ignore this bit. (It is clear from the number of index blocks   
!  when the bit is being used to indicate overflow.))             

     NDB=NB-1-NSQ-NXB
     DO I=NXB+1,NXB+NDB
        IX=ICHAR(MAP(I))
        IF (NXB.LT.128 .AND. IX.GT.128) IX=IX-128   
        INDB(IX)=INDB(IX)+1
     ENDDO
     NINDB = NXB + 1                                                

   ELSE                     ! New data set format      

     READ (1,REC=1) I, NB, NMAPBLK, NXB, NXM    

     J = 2 + NMAPBLK + NXB  ! Records before 1st data record  
     NDB = NB - J           ! Number of data records     
     J = 2*J + 1            ! Start of 1st map pointer   
     NMAP = 3               ! Number of first map record  
     
     READ (1,REC=NMAP) MAPREC(1:BLKSIZ) ! 1st map record                                         
     NINDB = NXB + NMAPBLK + 2  !
     ALLOCATE (INDB(0:NINDB))  
!                                            Clear out INDB array  
     DO I=0,NINDB                                              
        INDB(I) = 0                                             
     END DO              

     DO I=1,NDB                                 
       IF (J.GE.BLKSIZ) THEN  ! Get next map record   
          NMAP = NMAP + 1                                    
          READ (1,REC=NMAP) MAPREC(1:BLKSIZ)         
          J = 1                                      
        END IF                                         

        IX = ICHAR2(MAPREC(J:J+1)) ! Pointer to index record  
        INDB(IX) = INDB(IX) + 1                         
        J = J + 2                                            
      END DO                                                  
!      NINDB = NXB + NMAPBLK + 2                              
   END IF                                                     
!                                             Close MetDB data set
   CLOSE (1)                                                 

! Find the maximum data records for any index period, for comparison
! with the mean to see if one period has an unusually large total.

   MAX = 0                                                   
   DO I=1,NINDB                                              
      IF (INDB(I).GT.MAX) MAX = INDB(I)                       
   END DO                                                    

   MEAN = NINT((NDB-INDB(0))/FLOAT(NXB))  ! Mean no. of recs. 
   NUSE = NINT((NDB-INDB(0))/(0.01*NDB))  ! % data blks used  
   
   DEALLOCATE (INDB)

! IS is the start position of MDB subtype name. This is 6 for 1 ,
! (due to the prefix '/' of the DSN), and 5 for other systems -
! determined by checking for '/' in position 1 of the DSN. If not
! present, subtract 1 from IS=6.                                

   IS=6                                                       
   IF (DSN(1:1).NE.'/') IS=IS-1                               

! Assign prefix for merged data sets                              

   IF (INDEX(DSN,'.OPER.GAIR').GT.0) THEN                    
      PREFIX = '       Global merged '                         
   ELSE IF (INDEX(DSN,'.OPER.NAE').GT.0) THEN                
      PREFIX = '          NAE merged '                        
   ELSE IF (INDEX(DSN,'.OPER.MES4K').GT.0) THEN              
      PREFIX = '4km.Mesoscale merged '                         
   ELSE IF (INDEX(DSN,'.OPER.UKV').GT.0) THEN                
      PREFIX = '          UKV merged '                         
   ELSE IF (INDEX(DSN,'.OPER.GLBLNEMO').GT.0) THEN            
      PREFIX = '  Global NEMO merged '                        
   ELSE IF (INDEX(DSN,'.OPER.GSST').GT.0) THEN                
      PREFIX = '          SST merged '                         
   ELSE                                                       
      PREFIX = ' '                                             
   END IF
!                             Output statistics for this data set  

   I = INDEX(DSN(IS:),'.') - 2                                
   IF (I.LT.0) I = 7                                          
   WRITE (10,'(T2,2A,T31,I8,I15,I9,I13)')&                    
   PREFIX, DSN(IS:IS+I), NUSE, MEAN, MAX, NXM   
   
   DEALLOCATE (MAP) 
      
END DO
!                                Copy statistics to printed output 

! close program and then reopen with read only access.
! old f77 program just rewound unit 10 but this does not seem to work with f90
99 CLOSE (10)
OPEN (10,FILE='DD:STATS',ACTION='READ',IOSTAT=IRC)

! Initial IRC and LINE
IRC = 0                                                      
LINE = ' '                                                   

! loop over each line and print out to standard out
DO WHILE (IRC.EQ.0)                                          
   WRITE (6,'(A)') LINE                                      
   READ (10,'(A)',IOSTAT=IRC) LINE                           
END DO                                                       
!

! close open unit
CLOSE (10)                                                   
CLOSE (5)

! Stop and end program
STOP
END PROGRAM HOWFULL
